{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Intro","text":"Semgrep-based Policy controller for Kubernetes.  <p>Admission controller to use your well-known publicly available or custom Semgrep rules to validate k8s resources before deployment to the cluster.</p> <p> developed by </p> <p> powered by </p> <p> semgr8s is in a proof-of-concept state. Do not use in production. Breaking changes, service interruptions, and development flow adjustments are expected.</p>"},{"location":"#getting-started","title":"Getting started","text":"<p>Getting started to validate Kubernetes resources against Semgrep rules is only a matter of minutes:</p> <p> </p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>git</li> <li>Kubernetes cluster for testing (e.g. kind, microk8s, or minikube)</li> <li>kubectl</li> <li>Helm</li> <li>(optional) yq v4.x</li> <li>(optional) make (e.g. via build-essential)</li> <li>(optional) docker</li> </ul>"},{"location":"#get-code","title":"Get Code","text":"<p>Installation files are contained within this repository:</p> <pre><code>git clone https://github.com/semgr8ns/semgr8s.git\ncd semgr8s\n</code></pre>"},{"location":"#configuration-installation","title":"Configuration &amp; Installation","text":"<p>Semgr8s comes preconfigured with some basic rules. However, configuration can be adjusted to your needs:</p> <ul> <li>Central configuration is maintained in <code>charts/semgr8s/values.yaml</code>.</li> <li>Configuration aims to provide the most native integration of Semgrep's functionality into Kubernetes. Working knowledge of Kubernetes and the Semgrep documentation should be sufficient to understand the concepts and options being used here.</li> <li>Remote Semgrep rules, rulesets, repository rules are configured via <code>.application.remoteRules</code> in <code>charts/semgr8s/values.yaml</code>, e.g. set to <code>\"r/yaml.kubernetes.security.allow-privilege-escalation.allow-privilege-escalation\"</code> or <code>\"p/kubernetes\"</code>, or <code>\"r/yaml.kubernetes\"</code> respectively.</li> <li>Custom Semgrep rules can placed in <code>charts/semgr8s/rules/</code> and will be auto-mounted into the admission controller.</li> <li>Semgrep provides online tools to learn and create custom rules.</li> </ul> <p>To deploy the preconfigured admission controller simply run:</p> <pre><code>helm install semgr8s charts/semgr8s --create-namespace --namespace semgr8ns\n</code></pre> output <pre><code>NAME: semgr8s\nLAST DEPLOYED: Tue Apr 25 00:16:04 2023\nNAMESPACE: semgr8ns\nSTATUS: deployed\nREVISION: 1\nTEST SUITE: None\nNOTES:\nSuccessfully installed semgr8s!\n</code></pre> <p>You can check successful deployment of semgr8s via:</p> <pre><code>kubectl get all -n semgr8ns\n</code></pre> output <pre><code>NAME                           READY   STATUS    RESTARTS   AGE\npod/semgr8s-665dbb8756-qhqv6   1/1     Running   0          7s\n\nNAME                      TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE\nservice/semgr8s-service   ClusterIP   10.96.135.157   &lt;none&gt;        443/TCP   7s\n\nNAME                      READY   UP-TO-DATE   AVAILABLE   AGE\ndeployment.apps/semgr8s   1/1     1            1           7s\n\nNAME                                 DESIRED   CURRENT   READY   AGE\nreplicaset.apps/semgr8s-665dbb8756   1         1         1       7s\n</code></pre> <p>Once all resources are in <code>READY</code> state, you have successfully installed semgr8s </p>"},{"location":"#testing","title":"Testing","text":"<p>Several test resources are provided under <code>tests/demo/</code>. Semgr8s only validates resources in namespaces with label <code>semgr8s/validation=enabled</code>:</p> <pre><code>kubectl apply -f tests/demo/00_test-namespace.yaml\n</code></pre> output <pre><code>namespace/test-semgr8s created\n</code></pre> <p>It denies creating pods with non-compliant configuration according to the local rules in <code>charts/semgr8s/rules</code> and <code>.application.remoteRules</code> <code>charts/semgr8s/values.yaml</code>:</p> <pre><code>kubectl apply -f tests/demo/40_failing-deployment.yaml\n</code></pre> output <pre><code>Error from server: error when creating \"tests/demo/40_failing-deployment.yaml\": admission webhook \"semgr8s-svc.semgr8ns.svc\" denied the request: Found 1 violation(s) of the following policies: \n* rules.test-semgr8s-forbidden-label\nError from server: error when creating \"tests/demo/40_failing-deployment.yaml\": admission webhook \"semgr8s-svc.semgr8ns.svc\" denied the request: Found 1 violation(s) of the following policies: \n* yaml.kubernetes.security.writable-filesystem-container.writable-filesystem-container\nError from server: error when creating \"tests/demo/40_failing-deployment.yaml\": admission webhook \"semgr8s-svc.semgr8ns.svc\" denied the request: Found 1 violation(s) of the following policies: \n* yaml.kubernetes.security.privileged-container.privileged-container\nError from server: error when creating \"tests/demo/40_failing-deployment.yaml\": admission webhook \"semgr8s-svc.semgr8ns.svc\" denied the request: Found 1 violation(s) of the following policies: \n* yaml.kubernetes.security.hostnetwork-pod.hostnetwork-pod\n</code></pre> <p>Compliantly configured resources on the other hand are permitted to the cluster:</p> <pre><code>kubectl apply -f tests/demo/20_passing-deployment.yaml\n</code></pre> output <pre><code>pod/passing-testpod-1 created\n</code></pre>"},{"location":"#cleanup","title":"Cleanup","text":"<p>To remove all resources of the admission controller run:</p> <pre><code>helm uninstall semgr8s -n semgr8ns\nkubectl delete ns semgr8ns\n</code></pre> output <pre><code>release \"semgr8s\" uninstalled\n</code></pre> <p>Test resources are deleted via:</p> <pre><code>kubectl delete -f tests/demo/\n</code></pre> output <pre><code>namespace \"test-semgr8s\" deleted\npod \"passing-testpod-1\" deleted\nError from server (NotFound): error when deleting \"tests/demo/40_failing-deployment.yaml\": pods \"forbiddenlabel-pod\" not found\nError from server (NotFound): error when deleting \"tests/demo/40_failing-deployment.yaml\": pods \"failing-testpod-1\" not found\nError from server (NotFound): error when deleting \"tests/demo/40_failing-deployment.yaml\": pods \"failing-testpod-2\" not found\nError from server (NotFound): error when deleting \"tests/demo/40_failing-deployment.yaml\": pods \"failing-testpod-3\" not found\n</code></pre>"},{"location":"#next-steps","title":"Next steps","text":"<p>Excited about Semgr8s? Here is some next steps:</p> <ul> <li> For more details, checkout the docs, e.g. on Concept or Usage</li> <li> To share feedback, reach out via GitHub Discussions</li> <li> Report bugs via GitHub Issues</li> </ul>"},{"location":"concept/","title":"Concept","text":"<p>tl;dr</p> <ul> <li>Semgr8s is a Kubernetes admission controller</li> <li>Semgr8s directly integrates Semgrep under the hood</li> <li>Policy logic should be implemented via rules NOT Semgr8s configuration</li> <li>Rules are validated against admission requests that are similar to Kubernetes manifests</li> <li>Admission requests might exhibit some important differences to Kubernetes manifests</li> </ul>"},{"location":"concept/#basics","title":"Basics","text":"<p>Semgr8s is a policy controller for Kubernetes. By configuring rules, resources can be validated or even modified upon deployment to the cluster.</p> <p>Technically, Semgr8s implements the Semgrep engine as a Kubernetes admission controller in order to audit Kubernetes resources based on Semgrep-syntax rules. Rules are either provided as local resources via configmaps or reference to a remote Semgrep registry.</p> <p>Since admission requests resemble Kubernetes manifests and are converted by Semgr8s to compatible yaml format, custom rules can be developed based on knowledge about Kubernetes configuration and for example Semgrep's Kubernetes rules can be applied. It is, however, important to bear some differences in mind.</p> <p>Operationally, user changes to Kubernetes are applied via the Kube API that in turn exhibits admission phases. During admission Kubernetes sends change requests to admission controllers via webhooks. Semgr8s receives these so-called admission requests, validates them against preconfigured rules and returns the outcome: Admit, modify, or deny. Accordingly, the Kube API then either persists the (modified) requests to etcd for application or stops deployment.</p>"},{"location":"concept/#architecture-design","title":"Architecture &amp; Design","text":"<p>Semgr8s is developed for installation via helm to setup the required Kubernetes resources. However, rendering of Kubernetes manifests for usage with <code>kubectl apply</code> is expected to work as well.</p> <p>Configuration is maintained within <code>values.yaml</code> and kept at a minimum to maintain policy logic within rules (see philosophy).</p> <code>values.yaml</code> chart charts/semgr8s/values.yaml<pre><code>deployment:\n  image:\n    repository: ghcr.io/semgr8ns/semgr8s\n    pullPolicy: IfNotPresent\n    tag: \"\"\n  imagePullSecrets: []\n  replicas: 2\n  containerPort: 5000\n  podAnnotations: {}\n  podSecurityContext: {}\n  resources:\n    limits:\n      cpu: 1000m\n      memory: 128Mi\n    requests:\n      cpu: 100m\n      memory: 64Mi\n  securityContext:\n    allowPrivilegeEscalation: false\n    capabilities:\n      drop:\n        - ALL\n    privileged: false\n    readOnlyRootFilesystem: true\n    runAsNonRoot: true\n    runAsUser: 10001 # remove when using openshift or OKD 4\n    runAsGroup: 20001 # remove when using openshift or OKD 4\n    seccompProfile:\n      type: RuntimeDefault\n\nservice:\n  type: ClusterIP\n  port: 443\n\nwebhooks:  # configuration options for webhooks described under https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#webhook-configuration\n  validating: # main webhook\n    failurePolicy: Fail\n    sideEffects: None\n    timeoutSeconds: 30\n    admissionReviewVersions: [\"v1\",\"v1beta1\"]\n    namespaceSelector:\n      matchLabels:\n        semgr8s/validation: enabled\n    rules:\n      - scope: \"*\"\n        apiGroups: [\"\", \"apps\", \"batch\", \"networking.k8s.io\", \"rbac.authorization.k8s.io\"]\n        resources: [\"*/*\"]\n        apiVersions: [\"*\"]\n        operations: [\"CREATE\", \"UPDATE\"]\n  mutating: # autofix webhook, only used when enabled\n    failurePolicy: Fail\n    sideEffects: None\n    timeoutSeconds: 30\n    admissionReviewVersions: [\"v1\",\"v1beta1\"]\n    namespaceSelector:\n      matchLabels:\n        semgr8s/validation: enabled\n    rules:\n      - scope: \"*\"\n        apiGroups: [\"\", \"apps\", \"batch\", \"networking.k8s.io\", \"rbac.authorization.k8s.io\"]\n        resources: [\"*/*\"]\n        apiVersions: [\"*\"]\n        operations: [\"CREATE\", \"UPDATE\"]\n\napplication:\n  # Apply remote rules from e.g.\n  # * semgrep registry: https://semgrep.dev/r\n  # * semgrep-rules github repo: https://github.com/semgrep/semgrep-rules\n  # common choices: p/kubernetes, r/yaml.kubernetes\n  remoteRules: [\"p/kubernetes\"]\n  autofix: false\n</code></pre> <p>With exception of the admission webhook, all Semgr8s resources reside in its namespace <code>semgr8ns</code>. Semgr8s exhibits a validating and an optional mutating admission webhook for use with the autofix feature.</p> <code>webhook.yaml</code> chart charts/semgr8s/templates/webhook.yaml<pre><code>{{- $svc := (include \"semgr8s.serviceName\" .) -}}\n{{- $altNames := list -}}\n{{- $altNames = append $altNames (printf \"%s\" $svc) -}}\n{{- $altNames = append $altNames (printf \"%s.%s\" $svc .Release.Namespace) -}}\n{{- $altNames = append $altNames (printf \"%s.%s.svc\" $svc .Release.Namespace) -}}\n{{- $altNames = append $altNames (printf \"%s.%s.svc.cluster.local\" $svc .Release.Namespace) -}}\n{{- $certificate := genSelfSignedCert (printf \"%s.%s.svc\" $svc .Release.Namespace) nil $altNames 36500 -}}\n\napiVersion: v1\nkind: Secret\nmetadata:\n  name: {{ include \"semgr8s.TLSName\" . }}\n  labels:\n    {{- include \"semgr8s.labels\" . | nindent 4 }}\ntype: Opaque\ndata:\n  tls.crt: {{ $certificate.Cert | b64enc }}\n  tls.key: {{ $certificate.Key | b64enc }}\n---\napiVersion: admissionregistration.k8s.io/v1\nkind: ValidatingWebhookConfiguration\nmetadata:\n  name: {{ include \"semgr8s.webhookName\" . }}\nwebhooks:\n  - name: {{ .Chart.Name }}-svc.{{ .Release.Namespace }}.svc\n    {{- with .Values.webhooks.validating }}\n      {{- toYaml . | nindent 4 }}\n    {{- end }}\n    clientConfig:\n      service:\n        name: {{ include \"semgr8s.serviceName\" . }}\n        namespace: {{ .Release.Namespace }}\n        path: /validate/\n      caBundle: {{ $certificate.Cert | b64enc }}\n---\n{{- if .Values.application.autofix }}\napiVersion: admissionregistration.k8s.io/v1\nkind: MutatingWebhookConfiguration\nmetadata:\n  name: {{ include \"semgr8s.webhookName\" . }}\nwebhooks:\n  - name: {{ .Chart.Name }}-svc.{{ .Release.Namespace }}.svc\n    {{- with .Values.webhooks.mutating }}\n      {{- toYaml . | nindent 4 }}\n    {{- end }}\n    clientConfig:\n      service:\n        name: {{ include \"semgr8s.serviceName\" . }}\n        namespace: {{ .Release.Namespace }}\n        path: /mutate/\n      caBundle: {{ $certificate.Cert | b64enc }}\n{{ end }}\n</code></pre> <p>Their default configuration includes all <code>CREATE</code> and <code>UPDATE</code> for all apiGroups, resources, and apiVersions for namespaces with label <code>semgr8s/validation=enabled</code>. However, <code>Event</code> resources are manually dropped in application logic to suppress unnecessary load. The corresponding <code>/validate/</code> and <code>/mutate/</code> webhooks are exposed via HTTPS as a service that also handles load balancing.</p> <code>service.yaml</code> chart charts/semgr8s/templates/service.yaml<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: {{ include \"semgr8s.serviceName\" . }}\n  labels:\n    {{- include \"semgr8s.labels\" . | nindent 4 }}\nspec:\n  type: {{ .Values.service.type }}\n  ports:\n    - port: {{ .Values.service.port }}\n      targetPort: {{ .Values.deployment.containerPort }}\n  selector:\n    {{- include \"semgr8s.selectorLabels\" . | nindent 4 }}\n</code></pre> <p>The application logic is written in Python, exposed via cheroot webserver for performance, using flask framework for simplicity and maintainability, packaged in minimal container image based on Alpine and deployed as securely configured single Pod with configurable number of replicas (default: 2) for scalability and availability. The core functionality of rule validation against admission requests is implemented by directly integrating Semgrep.</p> <p>The Semgr8s application logic performs the following core functions:</p> <ul> <li>validate admission requests</li> <li>mutate admission requests</li> <li>update local rules</li> </ul> <p></p> <p>Semgrep is designed to scan files and consequently Semgr8s application logic manages rules, request and results data as files. As the container file system is configured as <code>readOnlyRootFilesystem</code>, corresponding volumes (<code>/app/rules/</code>, <code>/app/data</code>) and additional Semgrep folders (<code>/.semgrep/</code>, <code>/.cache</code>, <code>/tmp</code>) are provided via volume mounts. Performance-critical, small-size, ephemeral folders are mounted as tmpfs in order to avoid race conditions and timeouts at the expense of additional memory. The TLS certificate for HTTPS is provided as secret volume.</p> <p>For mutation and validation, an incoming admission requests is input validated, the admission object is converted to yaml and written to file. Semgrep is invoked on the admission request file using rules stored under <code>/app/rules/</code>. Additional configuration is passed as system arguments. Semgrep writes scan results to a results file that is parsed and rendered for admission response. After completion request and result file are deleted.</p> <p>Finally, Semgreps periodically runs an update job that gets the rule configmaps, decodes them and writes them to the file system under <code>/app/rules/</code>. The update job runs once every minute. Thus, adding new rules, modifying existing ones, or removing them can take up to 1min to propagate.</p> <p>While the local rules provided as configmaps and updated manually, Semgr8s configuration configmaps (including remote rules) are mounted as environment variables upon container creation and require a restart for updating. Semgr8s uses a service account with <code>list</code>/<code>get</code> configmaps permission in its own namespace to get updated rule configmaps.</p> role.yaml charts/semgr8s/templates/role.yaml<pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: {{ include \"semgr8s.roleName\" . }}\n  labels:\n    {{- include \"semgr8s.labels\" . | nindent 4 }}\nrules:\n- apiGroups: [\"*\"]\n  resources: [\"configmaps\"]\n  verbs: [\"list\", \"get\"]\n</code></pre>"},{"location":"concept/#admission-requests","title":"Admission requests","text":"<p>It is important to note that an admission request is in essence similar to Kubernetes manifests, but not the same and those differences might matter when writing policies. Consider a simple pod resource:</p> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: mypod\nspec:\n  containers:\n    - name: mycontainer\n      image: nginx\n</code></pre> <p>Semgr8s extracts the <code>object</code> from the admission request and ignores additional information. The (reduced) admission request takes the following form:</p> Admission request <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  annotations:\n    kubectl.kubernetes.io/last-applied-configuration: '{\"apiVersion\":\"v1\",\"kind\":\"Pod\",\"metadata\":{\"annotations\":{},\"name\":\"mypod\",\"namespace\":\"test-semgr8s\"},\"spec\":{\"containers\":[{\"image\":\"nginx\",\"name\":\"mycontainer\"}]}}'\n  creationTimestamp: '2024-05-10T13:47:01Z'\n  managedFields:\n  - apiVersion: v1\n    fieldsType: FieldsV1\n    fieldsV1:\n      f:metadata:\n        f:annotations:\n          .: {}\n          f:kubectl.kubernetes.io/last-applied-configuration: {}\n      f:spec:\n        f:containers:\n          k:{\"name\":\"mycontainer\"}:\n            .: {}\n            f:image: {}\n            f:imagePullPolicy: {}\n            f:name: {}\n            f:resources: {}\n            f:terminationMessagePath: {}\n            f:terminationMessagePolicy: {}\n        f:dnsPolicy: {}\n        f:enableServiceLinks: {}\n        f:restartPolicy: {}\n        f:schedulerName: {}\n        f:securityContext: {}\n        f:terminationGracePeriodSeconds: {}\n    manager: kubectl-client-side-apply\n    operation: Update\n    time: '2024-05-10T13:47:01Z'\n  name: mypod\n  namespace: test-semgr8s\n  uid: 2d28a432-6526-4022-96fa-cb9d0ff50756\nspec:\n  containers:\n  - image: nginx\n    imagePullPolicy: Always\n    name: mycontainer\n    resources: {}\n    terminationMessagePath: /dev/termination-log\n    terminationMessagePolicy: File\n    volumeMounts:\n    - mountPath: /var/run/secrets/kubernetes.io/serviceaccount\n      name: kube-api-access-xrkfj\n      readOnly: true\n  dnsPolicy: ClusterFirst\n  enableServiceLinks: true\n  preemptionPolicy: PreemptLowerPriority\n  priority: 0\n  restartPolicy: Always\n  schedulerName: default-scheduler\n  securityContext: {}\n  serviceAccount: default\n  serviceAccountName: default\n  terminationGracePeriodSeconds: 30\n  tolerations:\n  - effect: NoExecute\n    key: node.kubernetes.io/not-ready\n    operator: Exists\n    tolerationSeconds: 300\n  - effect: NoExecute\n    key: node.kubernetes.io/unreachable\n    operator: Exists\n    tolerationSeconds: 300\n  volumes:\n  - name: kube-api-access-xrkfj\n    projected:\n      defaultMode: 420\n      sources:\n      - serviceAccountToken:\n          expirationSeconds: 3607\n          path: token\n      - configMap:\n          items:\n          - key: ca.crt\n            path: ca.crt\n          name: kube-root-ca.crt\n      - downwardAPI:\n          items:\n          - fieldRef:\n              apiVersion: v1\n              fieldPath: metadata.namespace\n            path: namespace\nstatus:\n  phase: Pending\n  qosClass: BestEffort\n</code></pre> <p>While the original resource configuration is maintained, considerable additional information is added by the Kube API. Besides metadata and status information, most specification data explicitly declares implicit defaults or cluster specifics. With Semgr8s both, user-supplied Kubernetes manifest data and additionally added information, can be validated and mutated.</p> <p>It is certainly instructive to consider Kubernetes manifests and configuration knowledge during rule development, but it is imperative to bear in mind that rules validate admission requests in the end. Consider for example a rule that checks whether a <code>securityContext</code> is explicitly set and otherwise adds a secure configuration (see e.g. <code>run-as-non-root</code>). Above, we observe that the Kube API adds an explicit empty <code>securityContext</code> when none is provided and as a result the above rule offers no benefit.</p>"},{"location":"concept/#philosophy","title":"Philosophy","text":"<p>Implement policy logic via Semgrep rules to leverage its extensive rule syntax and maintain a single source of truth. Keep Semgr8s configuration at a minimum providing only basic global settings.</p> <p>Some configuration options for Semgr8s are available via <code>charts/semgr8s/values.yaml</code>. While these might allow to implement certain policies such as resource type restriction via admission webhook scoping, it is encouraged to keep these at the minimum and maintain the policy logic within rules in order to avoid unexpected conflicts.</p> <p>Similarly, Semgr8s is namespaced by restriction to namespaces with label <code>semgr8s/validation=enabled</code> which is intended as a fail safe (e.g. exclude <code>kube-system</code> or <code>semgr8ns</code>) not as a part of policy. Restricting a certain rule to a specific namespace is entirely possible within the Semgrep rule syntax.</p> <p>In essence, the configuration via <code>charts/semgr8s/values.yaml</code> should be aimed at the general scope of the policy controller and not towards policy itself. This philosophy should be kept in mind during development and usage of Semgr8s.</p>"},{"location":"usage/","title":"Usage","text":"<p>Understand how to plan, install and operate Semgr8s.</p>"},{"location":"usage/#considerations","title":"Considerations","text":"<p>Before integrating Semgr8s, it is important to bear a few considerations in mind:</p> <ul> <li>Semgr8s is still in an early stage of development with exciting ideas for improvement </li> <li>There is only limited operational experience so far and there might be breaking changes. We are happy for any feedback, bug reports, feature requests, and contributions via GitHub discussions,  issues and PRs </li> <li>Semgrep's yaml support is currently experimental.</li> <li>Semgr8s (like any other Kubernetes admission controller) can break a cluster when misconfigured. Therefore, testing should be rigorous and happen on a dedicated test cluster.</li> <li>Semgr8s can be used with remote rules. Those introduce an external dependence for validation which can affect performance and availability.</li> <li>Kubernetes admission controllers have maximum timeout of 30s which can require special attention for large deployments.</li> </ul>"},{"location":"usage/#setup","title":"Setup","text":"<p>Semgr8s is installed via Helm, but instructions can be adapted for usage with <code>kubectl apply</code> or your method of choice.</p>"},{"location":"usage/#requirements","title":"Requirements","text":"<ul> <li>git</li> <li>Kubernetes cluster for testing (e.g. kind, microk8s, or minikube)</li> <li>kubectl</li> <li>Helm</li> <li>(optional) make (e.g. via build-essential)</li> <li>(optional) yq v4.x</li> <li>(optional) docker</li> </ul>"},{"location":"usage/#get-code","title":"Get Code","text":"<p>The Helm charts are contained within the Semgr8s repository:</p> <pre><code>git clone https://github.com/semgr8ns/semgr8s.git\ncd semgr8s\n</code></pre>"},{"location":"usage/#configuration","title":"Configuration","text":"<p>Semgr8s comes preconfigured with some basic rules. However, configuration can be adjusted to your needs. Central configuration is maintained in <code>charts/semgr8s/values.yaml</code>:</p> <code>values.yaml</code> chart charts/semgr8s/values.yaml<pre><code>deployment:\n  image:\n    repository: ghcr.io/semgr8ns/semgr8s\n    pullPolicy: IfNotPresent\n    tag: \"\"\n  imagePullSecrets: []\n  replicas: 2\n  containerPort: 5000\n  podAnnotations: {}\n  podSecurityContext: {}\n  resources:\n    limits:\n      cpu: 1000m\n      memory: 128Mi\n    requests:\n      cpu: 100m\n      memory: 64Mi\n  securityContext:\n    allowPrivilegeEscalation: false\n    capabilities:\n      drop:\n        - ALL\n    privileged: false\n    readOnlyRootFilesystem: true\n    runAsNonRoot: true\n    runAsUser: 10001 # remove when using openshift or OKD 4\n    runAsGroup: 20001 # remove when using openshift or OKD 4\n    seccompProfile:\n      type: RuntimeDefault\n\nservice:\n  type: ClusterIP\n  port: 443\n\nwebhooks:  # configuration options for webhooks described under https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#webhook-configuration\n  validating: # main webhook\n    failurePolicy: Fail\n    sideEffects: None\n    timeoutSeconds: 30\n    admissionReviewVersions: [\"v1\",\"v1beta1\"]\n    namespaceSelector:\n      matchLabels:\n        semgr8s/validation: enabled\n    rules:\n      - scope: \"*\"\n        apiGroups: [\"\", \"apps\", \"batch\", \"networking.k8s.io\", \"rbac.authorization.k8s.io\"]\n        resources: [\"*/*\"]\n        apiVersions: [\"*\"]\n        operations: [\"CREATE\", \"UPDATE\"]\n  mutating: # autofix webhook, only used when enabled\n    failurePolicy: Fail\n    sideEffects: None\n    timeoutSeconds: 30\n    admissionReviewVersions: [\"v1\",\"v1beta1\"]\n    namespaceSelector:\n      matchLabels:\n        semgr8s/validation: enabled\n    rules:\n      - scope: \"*\"\n        apiGroups: [\"\", \"apps\", \"batch\", \"networking.k8s.io\", \"rbac.authorization.k8s.io\"]\n        resources: [\"*/*\"]\n        apiVersions: [\"*\"]\n        operations: [\"CREATE\", \"UPDATE\"]\n\napplication:\n  # Apply remote rules from e.g.\n  # * semgrep registry: https://semgrep.dev/r\n  # * semgrep-rules github repo: https://github.com/semgrep/semgrep-rules\n  # common choices: p/kubernetes, r/yaml.kubernetes\n  remoteRules: [\"p/kubernetes\"]\n  autofix: false\n</code></pre> <p>Configuration aims to provide the most native integration of Semgrep's functionality into Kubernetes. Working knowledge of Kubernetes and the Semgrep documentation should be sufficient to understand the concepts and options being used. In <code>charts/semgr8s/values.yaml</code>:</p> <ul> <li><code>.deployment</code> and <code>.service</code> only affect the Semgr8s deployment itself.</li> <li><code>.webhooks</code> allows configuration of validation scope (resources, operations, ...).</li> <li><code>.application</code> provides application-specific configuration (features, remote rules).</li> </ul> <p>Tip</p> <p>Use <code>.webhooks</code> to configure the overall Semgr8s scope. In production, this should be a careful trade-off between desired policy scope, availability, performance, and security.</p> <p>Rules form the basis to construct your policy. It is possible to either reference remote rules or add custom rules locally. Remote Semgrep rules, rulesets, or repository rules are configured via <code>.application.remoteRules</code> in <code>charts/semgr8s/values.yaml</code>, e.g. set to <code>\"r/yaml.kubernetes.security.allow-privilege-escalation.allow-privilege-escalation\"</code> or <code>\"p/kubernetes\"</code>, or <code>\"r/yaml.kubernetes\"</code> respectively. Custom Semgrep rules can be placed in <code>charts/semgr8s/rules/</code> and will be auto-mounted into the admission controller or added later as configmaps. Additional information on rule creation and management is shared below. Some useful example rules are provided under <code>./rules/</code>.</p> <p>At present, Semgr8s is shipped with one local test rule detecting a unique label and Semgrep's <code>p/kubernetes</code> ruleset.</p>"},{"location":"usage/#installation","title":"Installation","text":"<p>To deploy the preconfigured admission controller simply run:</p> <pre><code>helm install semgr8s charts/semgr8s --create-namespace --namespace semgr8ns\n</code></pre> output <pre><code>NAME: semgr8s\nLAST DEPLOYED: Tue Apr 25 00:16:04 2023\nNAMESPACE: semgr8ns\nSTATUS: deployed\nREVISION: 1\nTEST SUITE: None\nNOTES:\nSuccessfully installed semgr8s!\n</code></pre> <p>You can check successful deployment of semgr8s via:</p> <pre><code>kubectl get all -n semgr8ns\n</code></pre> output <pre><code>NAME                           READY   STATUS    RESTARTS   AGE\npod/semgr8s-665dbb8756-qhqv6   1/1     Running   0          7s\n\nNAME                      TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE\nservice/semgr8s-service   ClusterIP   10.96.135.157   &lt;none&gt;        443/TCP   7s\n\nNAME                      READY   UP-TO-DATE   AVAILABLE   AGE\ndeployment.apps/semgr8s   1/1     1            1           7s\n\nNAME                                 DESIRED   CURRENT   READY   AGE\nreplicaset.apps/semgr8s-665dbb8756   1         1         1       7s\n</code></pre> <p>Once all resources are in <code>READY</code> state, you have successfully installed Semgr8s.</p>"},{"location":"usage/#enable-namespaces","title":"Enable namespaces","text":"<p>To activate Semgr8s admission control for a namespace in default configuration, it is required to set the label <code>semgr8s/validation=enabled</code>. Either update the labels for existing namespaces directly via <code>kubectl</code>:</p> <pre><code>kubectl label namespace test-semgr8s semgr8s/validation=enabled --overwrite\n</code></pre> <p>Or extend the Kubernetes yaml files for target namespaces:</p> namespace.yaml<pre><code>---\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: test-semgr8s\n  labels:\n    semgr8s/validation: enabled\n</code></pre> <p>It is recommended to exclude cluster operation critical namespaces such <code>kube-system</code> to avoid interruptions.</p>"},{"location":"usage/#testing","title":"Testing","text":"<p>Several test resources are provided under <code>tests/demo/</code>. Semgr8s only validates resources in namespaces with label <code>semgr8s/validation=enabled</code>:</p> <pre><code>kubectl apply -f tests/demo/00_test-namespace.yaml\n</code></pre> output <pre><code>namespace/test-semgr8s created\n</code></pre> <p>It denies creating pods with non-compliant configuration according to the local rules in <code>charts/semgr8s/rules</code> and <code>.application.remoteRules</code> <code>charts/semgr8s/values.yaml</code>:</p> <pre><code>kubectl apply -f tests/demo/40_failing-deployment.yaml\n</code></pre> output <pre><code>Error from server: error when creating \"tests/demo/40_failing-deployment.yaml\": admission webhook \"semgr8s-svc.semgr8ns.svc\" denied the request: Found 1 violation(s) of the following policies: \n* rules.test-semgr8s-forbidden-label\nError from server: error when creating \"tests/demo/40_failing-deployment.yaml\": admission webhook \"semgr8s-svc.semgr8ns.svc\" denied the request: Found 1 violation(s) of the following policies: \n* yaml.kubernetes.security.writable-filesystem-container.writable-filesystem-container\nError from server: error when creating \"tests/demo/40_failing-deployment.yaml\": admission webhook \"semgr8s-svc.semgr8ns.svc\" denied the request: Found 1 violation(s) of the following policies: \n* yaml.kubernetes.security.privileged-container.privileged-container\nError from server: error when creating \"tests/demo/40_failing-deployment.yaml\": admission webhook \"semgr8s-svc.semgr8ns.svc\" denied the request: Found 1 violation(s) of the following policies: \n* yaml.kubernetes.security.hostnetwork-pod.hostnetwork-pod\n</code></pre> <p>Compliantly configured resources on the other hand are permitted to the cluster:</p> <pre><code>kubectl apply -f tests/demo/20_passing-deployment.yaml\n</code></pre> output <pre><code>pod/passing-testpod-1 created\n</code></pre>"},{"location":"usage/#cleanup","title":"Cleanup","text":"<p>To remove all resources of the admission controller run:</p> <pre><code>helm uninstall semgr8s -n semgr8ns\nkubectl delete ns semgr8ns\n</code></pre> output <pre><code>release \"semgr8s\" uninstalled\n</code></pre> <p>Test resources are deleted via:</p> <pre><code>kubectl delete -f tests/demo/\n</code></pre> output <pre><code>namespace \"test-semgr8s\" deleted\npod \"passing-testpod-1\" deleted\nError from server (NotFound): error when deleting \"tests/demo/40_failing-deployment.yaml\": pods \"forbiddenlabel-pod\" not found\nError from server (NotFound): error when deleting \"tests/demo/40_failing-deployment.yaml\": pods \"failing-testpod-1\" not found\nError from server (NotFound): error when deleting \"tests/demo/40_failing-deployment.yaml\": pods \"failing-testpod-2\" not found\nError from server (NotFound): error when deleting \"tests/demo/40_failing-deployment.yaml\": pods \"failing-testpod-3\" not found\n</code></pre>"},{"location":"usage/#features","title":"Features","text":""},{"location":"usage/#autofix","title":"Autofix","text":"<p>Semgr8s supports the Semgrep autofix feature. To use autofix, simply set <code>.application.autofix=true</code> in the <code>charts/semgr8s/values.yaml</code> before installation and provide <code>fix</code> instructions for your rules. Semgr8s will attempt to fix resources before validation.</p> <p>Technically, this is implemented via an additional mutating admission controller that is called before the validating admission controller.</p>"},{"location":"usage/#rules","title":"Rules","text":"<p>Rules form the core of Semgr8s functionality. They follow Semgrep syntax that provides an extensive pattern language. As admission requests resemble Kubernetes manifests, standard Kubernetes patterns can be directly used for Semgr8s. It is however important to keep some differences in mind. Rules can be provided in two different ways: remote rules and local rules. Remote rules are directly implemented from their external sources such the Semgrep registry. Local rules are provided as configmaps directly to Semgr8s.</p>"},{"location":"usage/#remote-rules","title":"Remote rules","text":"<p>Remote rules are directly used from external sources. They can be individual rules (e.g. <code>r/yaml.kubernetes.security.allow-privilege-escalation.allow-privilege-escalation</code>) or entire rulesets (e.g. <code>p/kubernetes</code>). Common sources are:</p> <ul> <li>Semgrep registry</li> <li>Semgrep registry repository</li> </ul> <p>For inspiration checkout Semgreps Kubernetes ruleset or the Kubernetes repository folder. They are added as a list under <code>.application.remoteRules</code> <code>charts/semgr8s/values.yaml</code>. Simply reference the respective rule(set) as you would for a local installation, e.g. <code>p/kubernetes</code>. Remote rules can currently only be configured prior to deployment and changes require re-installation of Semgr8s.</p> <p>Warning</p> <p>Remote rules require requests to external resources. This introduces delays, may lead to unexpected denial for rules modified by the external authority, and can cause failures if these resources become unavailable.</p>"},{"location":"usage/#local-rules","title":"Local rules","text":"<p>Local rules are your custom written rules and added as configmaps with label <code>semgr8s/rule=true</code> to Semgr8s's namespace <code>semgr8ns</code>. They can either be provided prior to installation as files under <code>charts/semgr8s/rules/</code> or added after deployment. Templates and selected rules are available under <code>./rules/</code>.</p> <p>Share your own rules </p> <p>We hope to continuously extend the list of selected rules to facilitate policy creation. So, please contribute your own favorite rules via PR </p>"},{"location":"usage/#adding-local-rules","title":"Adding local rules","text":"<p>Local rules are provided as configmaps that are frequently mapped as files into the semgr8s pod. Therefore, adding, modifying, or deleting local rules does not require an update of the deployment.</p> <p>To add a new rule, simply create a configmap from a standard semgrep rule yaml file and add the label <code>semgr8s/rule=true</code>: <pre><code>kubectl create configmap -n semgr8ns my-local-rule --from-file=path/to/rule.yaml\nkubectl label configmap -n semgr8ns my-local-rule semgr8s/rule=true\n</code></pre></p> <p>Info</p> <p>Semgr8s only updates its rules every 1min. Consequently, it can take up to 1min until the changes take effect. This accounts for adding, modifying, and deleting local rules.</p> <p>To delete the rule again, run: <pre><code>kubectl delete configmap -n semgr8ns my-local-rule\n</code></pre></p>"},{"location":"usage/#writing-rules","title":"Writing rules","text":"<p>Semgr8s rules follow Semgrep syntax and, therefore, must comply with the Semgrep rule requirements. For convenience, admission requests converted to yaml and consequently all rules should define yaml as language. A basic rule takes the form:</p> rules/template-rule.yaml<pre><code>rules:\n- id: template-rule\n  message: Rule template.\n  languages: [yaml]\n  severity: INFO\n  patterns:\n    - pattern: |\n        semgr8s-test: forbidden-test-label-e3b0c44298fc1c\n</code></pre> <p>In order to use the autofix feature, a fix value must be specified additionally:</p> rules/template-autofix-rule.yaml<pre><code>rules:\n- id: template-autofix-rule\n  message: Rule template with autofix.\n  languages: [yaml]\n  severity: INFO\n  patterns:\n    - pattern: |\n        semgr8s-test: forbidden-test-label-e3b0c44298fc1c\n  fix: \"semgr8s-test: allowed-test-label\"\n</code></pre> <p>While admission requests purposely share similarities with Kubernetes resource files, there is critical differences and additional information to consider when writing semgr8s rules. More details on admission requests are provided in the respective conceptual section. Rules should be carefully tested before rollout to production.</p> <p>Tip</p> <p>Semgrep provides provides extensive learning resources for writing your own rules. Interactive development without local setup is supported via the online playground.</p>"},{"location":"usage/#testing-rules","title":"Testing rules","text":"<p>Semgrep provides some convenient testing mechanisms out of the box. These can be leveraged to test rules locally before deployment. To validate rule syntax, Semgrep offers linting patterns:</p> <pre><code>semgrep scan --metrics-off --validate ./rules/\n</code></pre> <p>Testing functionality of rules requires tests. To assess the example rules, run:</p> <pre><code>semgrep scan --metrics=off --test ./rules/\n</code></pre>"},{"location":"usage/#typical-patterns","title":"Typical patterns","text":""},{"location":"usage/#restrict-to-resource-type","title":"Restrict to resource type","text":"<p>In order to restrict a rule to only certain resource types, simply prepend a <code>pattern-inside</code> expression for the desired resource type. In case of <code>Pod</code> resources, this takes the following form:</p> rules/forbidden-pod-label.yaml<pre><code>rules:\n- id: forbidden-pod-label\n  message: Kubernetes pod with forbidden label. Any pod with label \"semgr8s-test=forbidden-test-label-e3b0c44298fc1c\" is denied. This label carries no meaning beyond testing and demonstration purposes.\n  languages: [yaml]\n  severity: INFO\n  patterns:\n    - pattern-inside: |\n        ...\n        kind: Pod\n        ...\n    # remaining pattern as normal\n    - pattern-inside: |\n        metadata:\n          ...\n    - pattern-inside: |\n        labels:\n          ...\n    - pattern: |\n        semgr8s-test: forbidden-test-label-e3b0c44298fc1c\n  fix: \"semgr8s-test: allowed-test-label\"\n</code></pre> <p>It is also possible to use <code>pattern-not-inside</code> to only exclude a rule for one specific resource type. Multiple in-scope resource types can be defined via metavariable regular expressions:</p> rules/forbidden-workload-label.yaml<pre><code>rules:\n- id: forbidden-workload-label\n  message: Kubernetes workload with forbidden label. Any workload resource with label \"semgr8s-test=forbidden-test-label-e3b0c44298fc1c\" is denied. This label carries no meaning beyond testing and demonstration purposes.\n  languages: [yaml]\n  severity: INFO\n  patterns:\n    - pattern-inside: |\n        ...\n        kind: $KIND\n        ...\n    - metavariable-regex:\n        metavariable: $KIND\n        regex: (Pod|Deployment|ReplicaSet|DaemonSet|StatefulSet)\n    # remaining pattern as normal\n    - pattern-inside: |\n        metadata:\n          ...\n    - pattern-inside: |\n        labels:\n          ...\n    - pattern: |\n        semgr8s-test: forbidden-test-label-e3b0c44298fc1c\n  fix: \"semgr8s-test: allowed-test-label\"\n</code></pre>"},{"location":"usage/#restrict-to-specific-namespaces","title":"Restrict to specific namespaces","text":"<p>By prepending a <code>pattern-inside</code>, it is possible to restrict a rule to selected namespaces:</p> rules/forbidden-namespaced-label.yaml<pre><code>rules:\n- id: forbidden-namespaced-label\n  message: Kubernetes resource with label forbidden in designated namespace. Any resource with label \"semgr8s-test=forbidden-test-label-e3b0c44298fc1c\" is denied for this namespace. This label carries no meaning beyond testing and demonstration purposes.\n  languages: [yaml]\n  severity: INFO\n  patterns:\n    - pattern-inside: |\n        metadata:\n          ...\n          namespace: $NS\n        ...\n    - metavariable-regex:\n        metavariable: $NS\n        regex: (test-semgr8s|audit-semgr8s)\n    # remaining pattern as normal\n    - pattern-inside: |\n        metadata:\n          ...\n    - pattern-inside: |\n        labels:\n          ...\n    - pattern: |\n        semgr8s-test: forbidden-test-label-e3b0c44298fc1c\n  fix: \"semgr8s-test: allowed-test-label\"\n</code></pre> <p>This cannot extend beyond the enabled namespaces, but allows for more granular control on a per rule basis.</p>"},{"location":"usage/#delete-all-local-rules","title":"Delete all local rules","text":"<pre><code>kubectl delete -n semgr8ns cm -l semgr8s/rule=true\n</code></pre>"},{"location":"examples/deny-default-namespace/","title":"Deny <code>default</code> namespace","text":"<p>Deny resources deployed to the default namespace. For granular security controls, resources should be segregated by namespace.</p>"},{"location":"examples/deny-default-namespace/#use-rule","title":"Use rule","text":"<p>In order to use this rule:</p> <ol> <li>Create <code>configmap</code> via: <pre><code>kubectl create configmap -n semgr8ns deny-default-namespace --from-file=rules/deny-default-namespace.yaml\nkubectl label configmap -n semgr8ns deny-default-namespace semgr8s/rule=true\n</code></pre></li> </ol>"},{"location":"examples/deny-default-namespace/#rule","title":"Rule","text":"rules/deny-default-namespace.yaml<pre><code>rules:\n- id: deny-default-namespace\n  message: The default namespace should not be used. For granular security controls, resources should be segregated by namespace.\n  metadata:\n    likelihood: HIGH\n    confidence: HIGH\n    impact: LOW\n    category: security\n    technology:\n      - kubernetes\n    owasp:\n        - A04:2021 - Insecure Design\n        - K07:2022 - Network Segmentation\n    references:\n      - https://owasp.org/Top10/A04_2021-Insecure_Design/\n      - https://owasp.org/www-project-kubernetes-top-ten/2022/en/src/K07-network-segmentation\n  languages: [yaml]\n  severity: WARNING\n  patterns:\n    - pattern: |\n        metadata:\n          ...\n          namespace: $NS\n    - metavariable-regex:\n        metavariable: $NS\n        regex: (default)\n    - focus-metavariable: $NS\n</code></pre>"},{"location":"examples/forbidden-namespaced-label/","title":"Namespaced rules","text":"<p>Block resources with the forbidden test label in specific namespaces. The rule serves as an example to demonstrate how to restrict a rule to namespaces.</p>"},{"location":"examples/forbidden-namespaced-label/#use-rule","title":"Use rule","text":"<p>In order to use this rule:</p> <ol> <li>Adjust the label mapping to the target value.</li> <li>Adjust metavariable regular expression for <code>$NS</code> to your target namespaces.</li> <li>Create <code>configmap</code> via: <pre><code>kubectl create configmap -n semgr8ns forbidden-namespaced-label --from-file=rules/forbidden-namespaced-label.yaml\nkubectl label configmap -n semgr8ns forbidden-namespaced-label semgr8s/rule=true\n</code></pre></li> </ol>"},{"location":"examples/forbidden-namespaced-label/#rule","title":"Rule","text":"rules/forbidden-namespaced-label.yaml<pre><code>rules:\n- id: forbidden-namespaced-label\n  message: Kubernetes resource with label forbidden in designated namespace. Any resource with label \"semgr8s-test=forbidden-test-label-e3b0c44298fc1c\" is denied for this namespace. This label carries no meaning beyond testing and demonstration purposes.\n  languages: [yaml]\n  severity: INFO\n  patterns:\n    - pattern-inside: |\n        metadata:\n          ...\n          namespace: $NS\n        ...\n    - metavariable-regex:\n        metavariable: $NS\n        regex: (test-semgr8s|audit-semgr8s)\n    # remaining pattern as normal\n    - pattern-inside: |\n        metadata:\n          ...\n    - pattern-inside: |\n        labels:\n          ...\n    - pattern: |\n        semgr8s-test: forbidden-test-label-e3b0c44298fc1c\n  fix: \"semgr8s-test: allowed-test-label\"\n</code></pre>"},{"location":"examples/forbidden-pod-label/","title":"Scoping to pods","text":"<p>Block pods with the forbidden test label. The rule serves as an example to demonstrate how to restrict a rule to a specific resource type.</p>"},{"location":"examples/forbidden-pod-label/#use-rule","title":"Use rule","text":"<p>In order to use this rule:</p> <ol> <li>Adjust the label mapping to the target value.</li> <li>Adjust <code>kind: Pod</code> mapping to your target resource type.</li> <li>Create <code>configmap</code> via: <pre><code>kubectl create configmap -n semgr8ns forbidden-pod-label --from-file=rules/forbidden-pod-label.yaml\nkubectl label configmap -n semgr8ns forbidden-pod-label semgr8s/rule=true\n</code></pre></li> </ol>"},{"location":"examples/forbidden-pod-label/#rule","title":"Rule","text":"rules/forbidden-pod-label.yaml<pre><code>rules:\n- id: forbidden-pod-label\n  message: Kubernetes pod with forbidden label. Any pod with label \"semgr8s-test=forbidden-test-label-e3b0c44298fc1c\" is denied. This label carries no meaning beyond testing and demonstration purposes.\n  languages: [yaml]\n  severity: INFO\n  patterns:\n    - pattern-inside: |\n        ...\n        kind: Pod\n        ...\n    # remaining pattern as normal\n    - pattern-inside: |\n        metadata:\n          ...\n    - pattern-inside: |\n        labels:\n          ...\n    - pattern: |\n        semgr8s-test: forbidden-test-label-e3b0c44298fc1c\n  fix: \"semgr8s-test: allowed-test-label\"\n</code></pre>"},{"location":"examples/forbidden-workload-label/","title":"Scoping to multiple resource types","text":"<p>Block workloads with the forbidden test label. The rule serves as an example to demonstrate how to restrict a rule to a set of resource types.</p>"},{"location":"examples/forbidden-workload-label/#use-rule","title":"Use rule","text":"<p>In order to use this rule:</p> <ol> <li>Adjust the label mapping to the target value.</li> <li>Adjust metavariable regular expression for <code>$KIND</code> to your target resource types.</li> <li>Create <code>configmap</code> via: <pre><code>kubectl create configmap -n semgr8ns forbidden-workload-label --from-file=rules/forbidden-workload-label.yaml\nkubectl label configmap -n semgr8ns forbidden-workload-label semgr8s/rule=true\n</code></pre></li> </ol>"},{"location":"examples/forbidden-workload-label/#rule","title":"Rule","text":"rules/forbidden-workload-label.yaml<pre><code>rules:\n- id: forbidden-workload-label\n  message: Kubernetes workload with forbidden label. Any workload resource with label \"semgr8s-test=forbidden-test-label-e3b0c44298fc1c\" is denied. This label carries no meaning beyond testing and demonstration purposes.\n  languages: [yaml]\n  severity: INFO\n  patterns:\n    - pattern-inside: |\n        ...\n        kind: $KIND\n        ...\n    - metavariable-regex:\n        metavariable: $KIND\n        regex: (Pod|Deployment|ReplicaSet|DaemonSet|StatefulSet)\n    # remaining pattern as normal\n    - pattern-inside: |\n        metadata:\n          ...\n    - pattern-inside: |\n        labels:\n          ...\n    - pattern: |\n        semgr8s-test: forbidden-test-label-e3b0c44298fc1c\n  fix: \"semgr8s-test: allowed-test-label\"\n</code></pre>"},{"location":"examples/restrict-image-registry/","title":"Restrict image registry","text":"<p>Restrict source registries and repositories for container images deployed to the cluster. Unauthorized container image sources can lead to supply chain attacks via targeted or accidental creation of malicious workloads.</p>"},{"location":"examples/restrict-image-registry/#use-rule","title":"Use rule","text":"<p>In order to use this rule:</p> <ol> <li>Adjust metavariable-regex for <code>$IMG</code> in <code>rules/restrict-image-registry.yaml</code> (highlighted below)</li> <li>Create <code>configmap</code> via: <pre><code>kubectl create configmap -n semgr8ns restrict-image-registry --from-file=rules/restrict-image-registry.yaml\nkubectl label configmap -n semgr8ns restrict-image-registry semgr8s/rule=true\n</code></pre></li> </ol>"},{"location":"examples/restrict-image-registry/#rule","title":"Rule","text":"rules/restrict-image-registry.yaml<pre><code>rules:\n- id: restrict-image-registry\n  message: Container image reference points to non-designated registry / repository. Referencing unauthorized container image sources can lead to supply chain attacks via targeted or accidental creation of malicious workloads.\n  metadata:\n    likelihood: HIGH\n    confidence: HIGH\n    impact: HIGH\n    category: security\n    technology:\n      - kubernetes\n    owasp:\n        - A08:2021 - Software and Data Integrity Failures\n        - K02:2022 - Supply Chain Vulnerabilities\n    references:\n      - https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/\n      - https://owasp.org/www-project-kubernetes-top-ten/2022/en/src/K02-supply-chain-vulnerabilities\n  languages: [yaml]\n  severity: ERROR\n  patterns:\n    - pattern-inside: |\n        spec:\n          ...\n    - pattern-inside: |\n        containers:\n          ...\n    - pattern: |\n        image: $IMG\n    - metavariable-regex:\n        metavariable: $IMG\n        regex: ^(?!docker\\.io\\/library\\/).* # example for restriction to \"docker.io/library/\"\n    - focus-metavariable: $IMG\n</code></pre>"},{"location":"examples/template-autofix-rule/","title":"Template autofix rule","text":"<p>Template rule demonstrating minimal syntax for autofix rules at the example of a forbidden test mapping that is removed upon fixing.</p>"},{"location":"examples/template-autofix-rule/#use-rule","title":"Use rule","text":"<p>Warning</p> <p>Not for practical use. Rule is only provided as a minimal example. </p> <p>In order to use this rule:</p> <ol> <li>Create <code>configmap</code> via: <pre><code>kubectl create configmap -n semgr8ns template-autofix-rule --from-file=rules/template-autofix-rule.yaml\nkubectl label configmap -n semgr8ns template-autofix-rule semgr8s/rule=true\n</code></pre></li> </ol>"},{"location":"examples/template-autofix-rule/#rule","title":"Rule","text":"rules/template-autofix-rule.yaml<pre><code>rules:\n- id: template-autofix-rule\n  message: Rule template with autofix.\n  languages: [yaml]\n  severity: INFO\n  patterns:\n    - pattern: |\n        semgr8s-test: forbidden-test-label-e3b0c44298fc1c\n  fix: \"semgr8s-test: allowed-test-label\"\n</code></pre>"},{"location":"examples/template-rule/","title":"Template rule","text":"<p>Template rule demonstrating minimal syntax at the example of a forbidden test mapping.</p>"},{"location":"examples/template-rule/#use-rule","title":"Use rule","text":"<p>Warning</p> <p>Not for practical use. Rule is only provided as a minimal example. </p> <p>In order to use this rule:</p> <ol> <li>Create <code>configmap</code> via: <pre><code>kubectl create configmap -n semgr8ns template-rule --from-file=rules/template-rule.yaml\nkubectl label configmap -n semgr8ns template-rule semgr8s/rule=true\n</code></pre></li> </ol>"},{"location":"examples/template-rule/#rule","title":"Rule","text":"rules/template-rule.yaml<pre><code>rules:\n- id: template-rule\n  message: Rule template.\n  languages: [yaml]\n  severity: INFO\n  patterns:\n    - pattern: |\n        semgr8s-test: forbidden-test-label-e3b0c44298fc1c\n</code></pre>"}]}